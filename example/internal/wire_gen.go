// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package internal

import (
	"fmt"
	"github.com/craiggwilson/go-lifetime"
	"log"
)

// Injectors from wire.go:

func New(cfg *Config) (lifetime.Lifetime[*A], func()) {
	lifetimeLifetime := makeB(cfg)
	lifetime2, cleanup := makeD(cfg)
	lifetime3, cleanup2 := makeC(cfg, lifetime2)
	lifetime4, cleanup3 := makeA(cfg, lifetimeLifetime, lifetime3)
	return lifetime4, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}
}

// wire.go:

func makeA(cfg *Config, blife lifetime.Lifetime[*B], clife lifetime.Lifetime[*C]) (lifetime.Lifetime[*A], func()) {
	return lifetime.NewSingletonWithCleanup(func() (*A, error) {
		var b *B
		var err error
		if cfg.UseB {
			b, err := blife.Instance()
			if err != nil {
				return nil, fmt.Errorf("creating B: %w", b)
			}
		}

		var c *C
		if cfg.UseC {
			c, err = clife.Instance()
			if err != nil {
				return nil, fmt.Errorf("creating C: %w", c)
			}
		}

		return NewA(b, c), nil
	}, func(a *A) { log.Println("cleaning up A") })
}

func makeB(cfg *Config) lifetime.Lifetime[*B] {
	return lifetime.NewSingleton(func() (*B, error) { return NewB(), nil })
}

func makeC(cfg *Config, dlife lifetime.Lifetime[*D]) (lifetime.Lifetime[*C], func()) {
	return lifetime.NewSingletonWithCleanup(func() (*C, error) {
		d, err := dlife.Instance()
		if err != nil {
			return nil, fmt.Errorf("creating D: %w", d)
		}

		return NewC(d), nil
	}, func(c *C) { log.Println("cleaning up C") })
}

func makeD(cfg *Config) (lifetime.Lifetime[*D], func()) {
	return lifetime.NewSingletonWithCleanup(func() (*D, error) {
		return NewD(), nil
	}, func(d *D) { log.Println("cleaning up D") })
}
